# 简介
人工使用系统过程中，可能出现数据误修改、误删除等。后台在创建、修改、删除等操作时创建一个历史版本的数据，记录操作时间、操作类型、操作的表 ID、操作的数据前后具体情况。

有了历史数据，则可以在发现异常的时候进行数据恢复。现仅针对 postgres 数据库的数据记录历史信息，数据历史记录在 nosql 数据库中，并提供一个集成的查看操作界面。

该工具主要针对某些重要数据，用户删除掉之后又想找回，或者修改了某些数据，又想找到这数据某一个时间的状态。

比如，用户删除了一条博客，但是他后面觉得很重要，又需要找回来(这个需要考虑，可能是业务规范上的问题，所有的数据删除不要真删除，而是使用delete_at做出标识)

## 优点

这个工具最主要的特点就是接入简单，不需要修改现有业务代码，只需要在初始化数据库的地方再调用一下函数注册就行。

对于未做历史记录或其他数据恢复相关的业务，通过该工具能够很方便的处理，而不需要再去修改表结构或其他针对特定任务做的数据备份


## 如何使用

接入很方便，只需要将所需要监听的表传入构造函数中，以及日志保存路径(例如下文中的common.DataLogPath)

```Go
// 注册数据变更日志记录
datamanager.Register(system_model.DB(), nil,
    &request.TablePolicy{
        Table:     Company{},
        RelaField: "id",
        Relations: "company_rela.company_id",
    }, &request.TablePolicy{
        Table:     &CompanyRela{},
        RelaField: "company_id",
        Relations: "company.id",
    })
```

管理面板地址是 `/dblog/`

## 原理

基于表的触发器实现，为表上创建触发器，当发生数据更改的时候自动运行触发器将记录的操作进行保存，并且为了为了避免占用原有数据库太多空间，会有一个定时任务定期去读取记录并记录在本地leveldb中，用于后续查找


1、表注册后，初始化触发器，策略配置

2、当发生数据变化时，触发器将更新、删除、添加等记录存储在临时日志表

3、backend后台任务定时处理临时日志表，读取出来添加到任务队列确保消费者执行成功后再删除数据库中的日志，避免记录消失

4、日志存储消费者将日志存储在leveldb中，并封装提供一系列快速查找的api供查询使用，按照表、日期查询

## 缺点

数据变更时执行触发器 这肯定会对原有的数据执行性能产生影响, 所有考虑注册的表需要谨慎考虑

用于存储日志的leveldb是本地单机的，也就是说假如存在多服务的情况下，无法很好的访问日志

对于动态表，那些用于动态创建表字段等，由于触发器无法监听到这种行为，无法记录表结构的变化

多表的关系问题，通常在表结构中不会直接体现表的关联关系，而是在业务代码中体现，暂时为添加机制来记录各个表之间的数据关联关系

## 计划

添加多表关联的数据记录，需要在初始化插件的时候定义好表之间的依赖关系

使用监听数据库日志的方式来记录变更，不仅能够将ddl类型的log记录下来从而实现动态表结构变化的监听，还能取消对于触发器的依赖，减少触发器对性能造成的损耗

1、在策略表中添加多表关联的关系，在获取日志的时候，发现存在关联关系的一起读取出来

相等关系: 表a.a字段 表b.a字段, 在读取日志的时候遍历，只要存在相同，那么就去相应的日志记录中读取出来