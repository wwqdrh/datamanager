# 数据管理器

## 背景

人工使用系统过程中，可能出现数据误修改、误删除等。后台在创建、修改、删除等操作时创建一个历史版本的数据，记录操作时间、操作类型、操作的表ID、操作的数据ID、操作人、数据明细。有了历史数据，则可以在发现异常的时候进行数据恢复，提供一个通用的数据恢复方法。此需求暂时主要针对postgres数据库的数据记录历史信息，数据历史记录在nosql数据库中，需要提供一个集成的查看操作界面。

## 设计

·数据库触发器：用于获取数据操作动作和数据明细。
·操作临时记录表：用于临时存储触发器获取到的数据。
·临时数据转存：线程池调度执行器，从临时数据中提取相关信息，设定过期时间（默认一个月，每个表可单独配置）和保留数量（默认最后10条，每个表可单独配置，即使过期也要留存），存入nosql数据库并删除临时记录；注意：并不是所有的修改操作都需要记录，配置忽略字段组（如果只是修改了组内的字段，则忽略掉这个操作记录）。
·历史数据清理：定时从nosql数据库删除过期数据（需满足两个策略，时间过期，最后保留量）。
·数据恢复：用历史版本的数据修改指定的字段。
·配置管理：查看开启了数据版本的表和各表相关配置，提供必要的搜索功能，并可以修改配置；注意：操作人字段需要配置，也可能没有，数据ID需要获取表的主键字段。
·数据版本管理：查看和管理历史版本，提供必要的搜索功能，并可以恢复数据。

·参考https://git.zx-tech.net/ljhua/backend 项目，提供相应的路由注册方法，并将界面集成到go代码中（go-bindata）。

## 功能点

1、提供一种机制作为数据的快照 提供查询 恢复等操作
2、提供管理界面
3、作为backend接入到服务中
4、以数据表的维度进行策略的定制等

## 参考

1、存储快照的实现
[COW、ROW实现](https://juejin.cn/post/6844903639417372685)

2、使用表的触发器

单表的情况

- 修改: 需要存储修改前的值，然后加上版本号
- 删除: 需要存储目标删除的整段记录，需要修复则进行添加，(但是主键id自行指定是否可行?) 
- 添加: 要记录添加了id值，需要修复则进行删除对应的记录行

多表的情况

- 修改: 多个表无关联那么与单表一样不过是添加了集合，如果多个表有关系(一对一 一对多 多对多)，只要修改整体是一致的那么数据之间不会产生影响
- 删除: 多个表之间的关联性 可能会有数据处理的顺序问题
- 添加: 类似

> 分析知道只要整体的操作满足原子性，那么整体的就不会有问题，只需要注册一个语句的正向以及反向操作即可实现回滚

## 工作进度设计

在数据库的操作之间加一个中间件要么是gorm的中间件要么是表上的触发器，将原始的sql解析构造逆向sql语句并且添加上版本号，存储到某个版本数据存储库中，然后版本的处理是受到配置的策略进行处理的(包括过期策略、以及前面的触发哪些字段是需要监听的配置)， 提供依照版本库中的数据进行临时表创建以及修复，供给查看，历史数据的删除可以使用惰性删除，每次写完成的时候，查看有哪些是过期了的然后对过期数据进行删除。

### 表的注册以及反向操作的实现以及测试

因为其实整体的数据操作其实查询请求量不会很大，写倒是会很多，暂时就先用sqlite3实现

1、原始字符串以及反向的注册

postgres测试数据库的搭建，用线上的吧，方便

``` SQL
CREATE TABLE COMPANY(
   ID serial PRIMARY KEY,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);

INSERT INTO COMPANY (name, age, address, salary) VALUES 
('Mark', 25, 'Rich-Mond ', 65000.00 ), 
('David', 27, 'Texas', 85000.00);
```

查看gorm是否有对应的api，能够方便的提供所需要的字段，比如操作的什么表，更新的什么字段、历史值是多少，如果没有的话
就只能够自己实现对sql语句的解析(向这种需要考虑的东西很多)

act.Schema 表中包含的字段返回
act.Dest.data 目标字段以及目标值的映射

但是没有原生sql的解析操作，好像只能自己实现, 不过还是能够节省操作，首先构建model，解析出table 字段以及值 条件等等，然后再去构造，不过如果所需要的字段都解析完了 其实似乎也不需要再次去构造了

构造完成数据的反向操作之后如何查看某个版本的历史数据构成？有了现在的数据，有了回退的sql语句，需要显示的粒度是某个表的状态(select * from [table]), 创建临时表之后在临时表进行回滚操作，读出数据后再把临时表删除(虽然在磁盘空间中频繁操作表应该不太好，但是暂时对于sql的处理等暂时没有更好的方法，还是的依靠数据库原生的数据操作能力)

另外数据的改动是需要无感的 也就是说传入model之后 其他的crud操作不能发生改变，要么在表中添加触发器，要么在模型上动态添加中间件，不过似乎不太可行(因为用户引入还是只会引入它原先定义的模型 struct，新建的struct其实两个对象是不一样)

根据sql解析构造反向的sql 似乎依靠gorm无法很好实现 只能自己解析

然后为gorm.DB添加中间件，在数据执行前后打印消

``` golang
// begin transaction
BeforeSave
BeforeCreate
// save before associations
// insert into database
// save after associations
AfterCreate
AfterSave
// commit or rollback transaction

// 有一个问题就是这个hooks是只能针对模型的粒度，

// 需要使用callback， db.Callback().[action].[before|after].register(name, func)  这些就是全局处理的函数
```

2、表的策略设计，控制粒度的实现

> 策略数据库(sqlite3)

需要能够有哪些字段能够触发数据快照记录操作的设置 也就是说将模型引入之后需要有一个初始化操作，表中的记录字段包括: 表名、能够触发的字段(对那些字段产生了影响，比如update中的字段，如果是insert、delete的话则是默认会记录整个记录的操作)、过期时间的设置字段。

存储的话可以暂时就使用sqlite数据库(简化，平台依赖度低)

> 版本数据库(sqlite3)

其实也可以使用sqlite3进行存储，甚至version很可能会有很多操作，
可能还需要涉及到分表的操作之类。然后失效策略就使用懒惰删除，在查询的时候顺便对过期的历史记录进行删除

每一次操作都会创建版本数据库数据，包括版本号，正向执行的sql，反向执行的sql(留着，可以用来检查正反向的sql构建是否有问题)，并且每个版本都是增量的存储sql结构，其实跟redis的aof快照机制类似，都是存储执行的sql语句

然后当需要查看某个版本的数据情况的时候，会给版本号，会给表名，页数、分页之类的东西，根据版本号查询到目前为止的所有逆向sql操作，

(
    1、新建一个临时表，完全一样，然后在表中插入数据模拟然后读取删除这个临时表(但是这个表如果很大肯定是会有性能影响的)
    2、在原来的上面进行操作然后在进行恢复，这个肯定是需要添加事务，不能对其他对这个数据进行操作的请求时产生影响
)

有一个问题，现在的设计方案，所有的数据表的version都在一条线上，肯定不对，是需要拆分成每个表一个粒度的，多个表之间是可能相互影响。对于互相产生影响的情况下，可以使用一个全局唯一的id，如果某几个表之间有相同的id，并且需要回退到这个版本，那么这些都必须回退到这，回退之后不能直接删除，而是添加新的记录，这样的话这个回退也是可以回退的。

TODO: 完成数据version写表，需要有version id，牵扯多个表的情况是需要有个统一的versionid生成机制，当相同的时候就对回滚至这个versionid就行

需要删除的数据的所有值的数据 delete 范围删除 那么对应的就需要把整个范围的数据都存储起来并

还有 对于多个表的情况 sql语句肯定是需要完成拆分功能 。这样才能处理多个表的情况。
